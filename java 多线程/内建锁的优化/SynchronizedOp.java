package SynchronizedOP;

public class SynchronizedOp {
    public static void main(String[] args) {


    }
}
/*
 一、锁的优化
优化的是分情况将获取锁的时间大大缩短了，使整体效率变高了。

铺垫：
（1）CAS操作
（2）Java 对象头

一、1CAS
1.1 CAS操作（原子性操作）
悲观锁策略：使用锁的时候 ，线程获取锁是一种悲观策略，假设每次执行临界区的代码都会产生冲突，所以当前线程获取锁的
时候同时也会阻塞其他线程获取该锁。

乐观锁策略：而CAS操作（简称无锁操作）是一种 乐观锁策略 ，它假设所有线程访问共享资源的时候不会出现冲突，
既然不会出现冲突自然而然的就不会阻塞其他线程的操作。因此，线程就不会出现阻塞停顿的状态。

那么，如果出现冲突了，乐观锁策略（假定无锁）是使用CAS(compare and swap)又叫做比较交换来鉴别线程
是否出现冲突，出现冲突就重试当前操作直到没有冲突为止。

1.2CAS的操作过程。

三个阶段（V，O，N）

V:内存中地址存放的实际值

O:预期值（旧址）

N:更新后的值


当旧值O（当前线程栈中该数据存储的值）和实际值V相同时：明确表示该值没有被
其他线程更改过，即该旧址O就是目前来说内存中该数据刷新的后的最新的值，
自然而然的将新值N赋给V,反之，V和O指不同时，表明该值已经被其他线程改过了
则该旧值不是当前该数据的最新值，所以不能将新值付给V,返回V即可。
当多个线程使用CAS操作一个变量时，只有一个线程会成功，并成功更新，其余都会失败。
失败的线程会重新尝试，当然也可以选择性的挂起线程。

CAS的实现需要硬件指令集的支持，在JDK1.5后虚拟机才可以使用处理器提供CMPXCHG指令实现。
元老级的Synchronized（未优化）最主要的问题是：在存在线程竞争的情况下会出现线程阻塞和
唤醒锁带来的性能问题，因为这是一种互斥同步（阻塞同步）。而CAS并不是武断的将线程挂起，当CAS操作失败后
会进行一定的尝试，而非进行耗时的挂起唤醒操作，因此也叫非阻塞同步。这是两者主要区别。

1.3CAS的问题
I
ABA 问题：增加版本号在修改的数据前。

II
自旋会浪费大量的处理器资源

与线程阻塞相比，自旋会浪费大量的处理器资源，这是因为当前线程仍处于运行状态，之不过是无用的指令。
它期望在运行无用指令的过程中，锁能够被释放出来。

所以采用自适应自旋：
根据以往自旋等待时能否获取到锁，来动态调整自旋的时间（循环尝试得数量）

具体策略：如果上次自旋时获取到锁，则此次自旋的时间稍长一点；如果在上次自旋的结束好还没有获得锁，此时
自旋时间稍短一点

III公平性的问题
自旋状态还带来另一个副作用，不公平的锁机制。处于阻塞状态的线程，无法立即竞争被释放的锁。然而，
处于自旋状态的线程，则很有可能优先获得这把锁

内键锁无法实现公平性。
Lock体系可以实现公平锁。


一、2java对象头
JDK1.6之后对内键锁进行了优化（新增偏向锁，轻量级锁）
锁状态在对象头的Mark Word中

Mark Word的状态变化 4字节

Mark Word的锁标记位2bit
无锁  0  01；
偏向锁1  01；
轻量级锁 00；
重量级锁（JDK1.6之前） 10
GC标记                01
这四种状态随着竞争的情况逐渐升级，但是不能降级 ，目的是：为了提高锁的利用率

重量级锁的Mark Word 30bit 指向互斥量（重量级锁）的指针  10
轻量级锁的Mark Word 30bit 指向栈中锁的记录的指针       00
偏向锁 的Mark Word  23bit 线程ID 2bit Epoch 4bit 对象分代年龄
                  1 bit 是否是偏向锁 1                01
无锁  的mark Word   25bit 对象的hashCode 4bit 对象分代年龄
                  1 bit 是否是偏向锁 0                01
Gc  --对象释放


A.偏向锁

2.1偏向锁 ：最乐观的随，从始至终只有指定一个线程可以获取这把锁，（一线程一锁）


当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向（指定）的
线程ID,以后该线程在进入和退出同步快时就不需要进行CAS操作来加锁和解除锁，只需要简单的
测试一下对象头的Mark Word 里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获取到锁。
如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示是当前是偏向锁）：
如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。

2.2偏向锁的撤销

偏向锁使用了一种等到竞争才出现释放的机制，所以当前线程尝试竞争那个偏向锁的时候，持有偏向锁的线程才会释放锁



2.2偏向锁的获取
    a.是否是偏向锁     1
    b.检查对象头中是否存储了线程1
        b.1没有
            C CAS替换Mark Word
               线程ID 以及其他

                成功则将对象头Mark Word 中的线程ID指向自己。并将锁标记为1 01
                执行同步块

             C CAS替换Mark Word
               线程ID 以及其他

               失败（Mark Word 已将存储一个线程的ID,所以CAS失败）自旋，不断尝使用CAS试获取锁，或者将偏向锁撤销，或升级为轻量级锁（升级概率大）
               自旋（Epoch 次数记录自旋次数 >40升级（默认） ）

                    I.撤销：1.等到全局安全点（当前没有字节码进行运行）
                          2.暂停拥有偏向锁的线程
                          3.检擦该线程是否活着
                            N:对象头设置为无锁状态
                            Y:Mark Word 偏向其他线程 或者 恢复到无所或者标记该对象不适合作为偏向锁（ ID:null  锁标记0 01 ）
                          4.恢复暂停的线程。
                   II.升级：//先撤销偏向锁（ID:null 0 01），//然后让偏向锁升级为轻量级锁，在进行竞争。
        b.2 有
          不需要CAS操作，直接在代码块中运行（锁的重入）减少开销


B.轻量级锁
2.1轻量级锁：
不同时间段请求同一把锁，也就是没有锁竞争。针对这种情况，JVM采用了轻量级锁。来避免线程的阻塞以及唤醒。
JVM采用轻量级锁来避免线程的阻塞以及唤醒。

2.2轻量级锁的加锁，轻量级锁的解锁
a.访问同步块(当前锁为无锁状态 0 01)

b.JVM会先在当前线程得帧栈中创建用于存储锁记录得空间,并将对象头中得Mark Word复制到锁得记录中（Displaced Mark Word）

c.然后线程尝试使用CAS将对象头中得Mark Word替换为指向锁记录得指针
    失败：已将有线程已经获取到锁 自旋获取锁
            失败 锁膨胀，修改为重量级锁（10）
                当前线程阻塞

    成功：将Mark Word 替换为轻量级锁->指向站的指针   （锁标记）00
            执行同步同步块
                当再次执行同步块时，进行CAS操作时 失败 因为有线程在争夺锁
                    释放锁并唤醒在阻塞等待的线程 （当前锁已经膨胀为重量级锁 10，有线程已将Mark Word更改为指向重量级锁的指针了，所以这里的线程会CAS失败）


   （被阻塞的线程）线程被唤醒，重新争夺锁访问同步块（当前锁由于竞争已经升级为重量级锁）

一旦锁升级为重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁的时候，会被阻塞住
当持有锁的线程释放锁以后会唤醒这些锁，被唤醒的线程就会进行新一轮的夺锁之争。


C重量级锁

3.3.重量级锁
重量级锁是JVM最为基础的锁实现。这种状态下，JVM虚拟机会阻塞加锁失败的线程，并且字目标锁被释放的时候
唤醒这些线程。
Java 的线程阻塞以及唤醒都是依操作兄来完成的。举例来说，对于符合posix接口的操作系统（如macOs和绝大部分的linux），
上述操作通过pthread的互斥锁（mutex）来实现的。此外这些操作设计系统调用，需要从操作系统的用户态切换为内核态，其开销十分大。

为了尽量避免昂贵的线程组阻塞，唤醒操作，JVM会在线程进入阻塞状态之前，以及被唤醒之后竞争不到锁的情况下进入自旋状态，在处理器上空跑并且轮询锁是否被释放。
如果此时锁恰好被释放了，那么当前线程便无须进入阻塞状态，而是直接获得这把锁。


总结：
Java虚拟中的sychronized关键字的实现，按照代价由高到低可以分为重量级锁、轻量级锁，偏向锁三种

1.重量级锁会阻塞，唤醒请求加锁的线程，他针对的是多线程同时竞争一把锁的情况。JVM采用了自适应自旋，来避免线程在面对非常小的
synchronized代码块时，仍被阻塞，唤醒的情况。
2.轻量级锁采用CAS操作，将锁对象的标记字段替换为一个指针，指针指向当前线程栈上的一块空间，存储着锁对象原本标记的字段。
它针对的时多个线程在不同时间段申请同一把锁的情况。
3.偏向锁只会在第一次请求时采用CAS操作，在锁对象的标记字段中记录下当前线程的地址（线程ID）。在之后运行过程中，持有该偏向锁的线程的加锁操作
将直接返回。它针对的时锁仅会被同一线程持有的情况。

4其他锁的优化

锁粗化

锁粗化：就是将多次链接在一起的加锁，解锁操作合并为一次，将多个连续的锁扩展为一个范围更大的锁。
pubic class Test{

    priavte static StringBuffer sb = new StringBuffer();
    public static void main(String[]args){
        sb.append("a");
        sb.append("b");
        sb.append("c");
        }
    }
这里每次调用StringBuffer.append方法都需要加锁和解锁，如果有虚拟机检测到一系列连串的对同一个对向加锁
解锁操作，就会将其合成一次范围更大的加锁和解锁操作，即在第一次append方法时进行加锁，最后一次append方法结束后进行解锁。



锁消除
锁消除即删除不必要的加锁操作。根据代码逃逸技术，如果判断到一段代码中，堆上的数据不会逃逸出当前线程，
呢么可以认为这段代码时线程安全的，不必要加锁。
public class Test{
    public static void main(String []args){
        StringBuffer sb = new StringBuffer();
        sb.append("a").append("b").append("c");
       }
   }
虽然StringBuffer 的append是一个同步方法，但是这段程序中的StirngBuffer属于一个局部变量，并不会从该方法中逃逸出去，所以其实这个过程线程是安全的，可以将锁消除。












 */


